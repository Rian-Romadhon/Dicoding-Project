# -*- coding: utf-8 -*-
"""Submission Image Classification & Deployment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jADqfo8cL8VGxph-dqY5FjVgWvSJ3lwt

#**Submission Image Classification & Deployment**

Pada submission ini saya akan membuat model untuk memprediksi gambar-gambar intel (glacier, laut, hutan, jalanan, gunung, dan bangunan ). Total ada 6 kelas. Dataset yang saya gunakan dapat diakses pada link di bawah ini:

https://www.kaggle.com/puneet6060/intel-image-classification
"""

#install kaggle untuk mendapatkan akses ke dataset
!pip install kaggle

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d puneet6060/intel-image-classification

import os, zipfile
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Dense, MaxPooling2D, Flatten, Dropout, Conv2D
from tensorflow.keras.models import Sequential
from keras.applications import VGG16

#ekstrak file
path = '/content/intel-image-classification.zip'
zip_ref = zipfile.ZipFile(path, 'r')
zip_ref.extractall('/tmp')
zip_ref.close()

base_dir = '/tmp/seg_train/seg_train'

#mengolah gambar dengan image data generator
generator = ImageDataGenerator(rescale=1/255,
                               validation_split=0.2)


train_dataset = generator.flow_from_directory(batch_size=20,
                                                    directory=base_dir,
                                                    target_size=(150,150),
                                                    subset='training',
                                                    class_mode='categorical')

val_dataset = generator.flow_from_directory(batch_size=20,
                                                directory=base_dir,
                                                target_size=(150,150),
                                                subset='validation',
                                                class_mode='categorical')

#Membuat callback
class Callback(tf.keras.callbacks.Callback):
    def on_epoch_end(self, epoch, logs={}):
      if(logs.get('accuracy')>0.9):
        print("\nPelatihan Berhenti Karena Akurasi telah mencapai >90%")
        self.model.stop_training = True
callback = Callback()

#membuat model (saya menambahkan model VGG16 ke dalam model sekuensial)
conv_base = VGG16(
                  weights = 'imagenet',
                  include_top = False,
                  input_shape = (150,150,3)
                 )
#Di dalam model ini sudah terdapat layer Conv2D dan Maxpooling2D
conv_base.summary()

model = Sequential()
model.add(conv_base)
model.add(Flatten())
model.add(Dense(250, activation='relu'))                    
model.add(Dropout(0.5))
model.add(Dense(6,activation='softmax'))

#compile dan fit model
model.compile(loss='categorical_crossentropy',
              metrics=['accuracy'],
              optimizer=tf.optimizers.Adam(lr=2e-5))

history=model.fit(train_dataset,
                  epochs=30,
                  validation_data=val_dataset,
                  verbose=1,
                  callbacks=[callback],
                  steps_per_epoch=30,
                  validation_steps=30)

#visualisasi 
import matplotlib.pyplot as plt

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss=history.history['loss']
val_loss=history.history['val_loss']

epochs_range = range(30) 
plt.figure(figsize=(10, 10))

#visualisasi training and validation accurancy
plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.title('Training and Validation Accuracy')

#visualisasi training and validation loss 
plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.title('Training and Validation Loss')
plt.show()

# Mengkonversi model menjadi .tflite
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

with tf.io.gfile.GFile('model.tflite', 'wb') as f:
  f.write(tflite_model)

# Commented out IPython magic to ensure Python compatibility.
#test model
import numpy as np
from keras.preprocessing import image
import matplotlib.image as mpimg
# %matplotlib inline

uploaded = files.upload()
 
for fn in uploaded.keys():
 
  # prediksi gambar
  path = fn
  img = image.load_img(path, target_size=(150,150))
  imgplot = plt.imshow(img)
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
 
  images = np.vstack([x])
  classes = model.predict(images, batch_size=20)

  print(fn)
  if np.all(classes == [1,0,0,0,0,0]):
    print('BUILDING')
  elif np.all(classes == [0,1,0,0,0,0]):
    print('FOREST')
  elif np.all(classes == [0,0,1,0,0,0]):
    print('GLACIER')
  elif np.all(classes == [0,0,0,1,0,0]):
    print('MOUNTAIN') 
  elif np.all(classes == [0,0,0,0,1,0]):
    print('SEA')
  elif np.all(classes == [0,0,0,0,0,1]):
    print('STREET')     
  else:
    print('error')